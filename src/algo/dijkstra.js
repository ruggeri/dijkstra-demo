const Fringe = require('./fringe');
const ResultEntry = require('./resultEntry');
const ResultMap = require('./resultMap');

// Runs Dijkstra's algorithm from a start vertex. Will run the A*
// variant if you supply a heuristic.
//
// This is a generator function. It yields messages along the way about
// what it is doing.
function* dijkstra(startVertex, heuristic) {
  let result = new ResultMap();
  let fringe = new Fringe();

  // Initial vertex has zero cost and no prev edge.
  ({ fringe } = fringe.addEntry(new ResultEntry(
    startVertex,
    null,
    0,
    heuristic ? heuristic(startVertex) : null
  )));

  yield {
    name: 'INITIAL_STATE',
    result,
    fringe,
  };

  while (!fringe.isEmpty()) {
    // Extract minimum cost entry, lock in this path to the vertex.
    let minimumEntry;
    ({ minimumEntry, fringe } = (
      fringe.extractMinimumEntry()
    ));
    result = result.addEntry(minimumEntry);

    yield {
      name: 'EXTRACT_ENTRY',
      minimumEntry,
      fringe,
      result,
    };

    // Yield all the messages that are generated by processExtractedEntry.
    // Note that I use a callback to record the final state of the
    // fringe.
    yield processExtractedEntry(minimumEntry, fringe, result, heuristic, (newFringe) => {
      fringe = newFringe;
    });

    yield {
      name: 'UPDATE_COMPLETE',
      fringe,
      result,
    };
  }

  yield {
    name: 'FINAL_RESULT',
    fringe,
    result,
  }
}

// Processes all edges out of a newly extracted minimum entry.
//
// This generator will yield messages about what it is doing.
//
// Because fringe is immutable, we let the caller know about the final
// updated fringe via the callback. It isn't simple to just return the
// new fringe because the other yielded objects are all messages.
function* processExtractedEntry(minimumEntry, fringe, result, heuristic, cb) {
  // Consider each edge out of the just extracted vertex.
  for (const evPair of minimumEntry.toVertex.edgeVertexPairs()) {
    const [edge, toVertex] = evPair;

    // Get the current path to the toVertex (if any).
    const currentEntry = fringe.currentEntry(toVertex);
    // Compute the cost of the newly discovered path.
    const newCostToVertex = minimumEntry.costToVertex + edge.cost;
    const heuristicCost = heuristic ? heuristic(toVertex) : null;

    const newEntry = new ResultEntry(
      toVertex,
      edge,
      newCostToVertex,
      heuristicCost,
    )

    yield {
      name: 'CONSIDER_EDGE',
      // entry we just locked in.
      fromEntry: minimumEntry,
      // current entry for the toVertex for the edge
      currentEntry: currentEntry,
      // newly found path to the toVertex for the edge.
      newEntry: newEntry,
      fringe,
      result
    };

    // Don't bother trying to discover new paths to results already
    // locked in.
    if (result.hasVertex(toVertex)) {
      continue;
    }

    // Try adding to the fringe. addEntry tells us whether the fringe
    // was changed.
    ({ didUpdate, fringe } = fringe.addEntry(newEntry))

    if (didUpdate) {
      yield {
        name: 'UPDATE_FRINGE',
        prevEntry: currentEntry,
        newEntry,
        fringe,
        result,
      };
    }
  }

  cb(fringe);
}

module.export = dijkstra;
